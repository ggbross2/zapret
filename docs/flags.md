## Основная идея: Обмануть "Интернет-Цензора"
Ваш интернет-провайдер установил специальную систему (называется DPI, у русских ТСПУ), которая следит за всем вашим интернет-трафиком. Если этой системе что-то не нравится (например, Вы пытаетесь зайти на заблокированный сайт), она может заблокировать доступ и разорвать соединение.

Программа типа Zapret (в данном случае nfqws), пытается "обмануть" эту систему-цензора. Она берет ваш запрос к сайту и немного его изменяет - так, чтобы сайт Вас понял, а вот "цензор" запутался и пропустил ваш запрос до адресата.

Она "ловит" ваши пакеты данных перед тем, как они уйдут в интернет, колдует над ними и отправляет дальше. Чтобы она их ловила, нужны специальные правила в системе (это iptables или nftables – своего рода "регулировщики трафика" в Linux).

## --dpi-desync
Главный инструмент для активного "обмана" DPI путем отправки искаженных или дополнительных пакетов, которые сбивают DPI с толку, но позволяют реальному серверу правильно обработать ваш запрос.

Обычно режимы указываются в порядке "фаз": сначала из фазы 0 (если нужно), потом из фазы 1, потом из фазы 2. Например: `--dpi-desync=fake, multisplit`

Разные "Интернет-Цензоры" (DPI) работают по-разному и имеют разные слабости. Какой-то DPI можно обмануть простым fake. Для другого понадобится комбинация из fake + badsum + multidisorder с определенными позициями нарезки. Часто приходится экспериментировать, чтобы найти рабочий вариант для Вашего провайдера.

Это означает: сначала послать поддельный запрос (fake), а потом настоящий запрос разрезать на кусочки (multisplit) и отправить.

### Фаза 0
Фаза когда Вы только-только начинаете разговор с сайтом.
- `synack`: Вы отправляете первый пакет "Привет, хочу подключиться!" (SYN). В ответ программа может послать пакет, который выглядит так, будто сервер Вам ответил согласием (SYN-ACK), хотя на самом деле это еще не так. ТСПУ может подумать, что уже все нормально, и ослабить бдительность.
- `syndata`: В самый первый пакет "Привет!" (SYN) добавляется немного "мусорных" данных. Обычные серверы этот мусор проигнорируют, а ТСПУ может попытаться его проанализировать и запутаться.

### Фаза 1
Отправка чего-то перед вашим настоящим запросом
- `fake`: Самый популярный трюк. Перед тем, как отправить Ваш настоящий запрос (например, "дай мне сайт Х"), программа отправляет совершенно другой, "безобидный" запрос (например, "дай мне сайт Google"). ТСПУ видит этот безобидный запрос, решает, что все в порядке, и может не так внимательно смотреть на ваш следующий, уже настоящий, запрос к сайту Х.
- - Чтобы этот поддельный запрос не дошел до настоящего сайта Google и не вызвал ошибок, используются дополнительные "обманки" из параметра `--dpi-desync-fooling` (например, испортить контрольную сумму пакета, чтобы Google его отбросил, или установить очень маленькое "время жизни" пакета, чтобы он "умер" по пути).
  - Можно указать, какой именно поддельный запрос слать:
  - - `--dpi-desync-fake-http=<файл>`: Использовать содержимое файла как поддельный HTTP-запрос.
    - `--dpi-desync-fake-tls=<файл>`: Для HTTPS. Можно даже взять настоящий запрос к разрешенному сайту и использовать его как "прикрытие".
- `rst` или `rstack`: Послать пакет "сброса соединения" (RST). ТСПУ может подумать, что вы сами разорвали соединение и перестанет следить. А ваш компьютер и сервер на самом деле продолжат общение, зная, что RST был ложным.

### Фаза 2
Изменение самого вашего запроса или его частей
- `multisplit`: Ваш запрос (например, `GET /kartinka.jpg HTTP/1.1`) "нарезается" на очень много мелких кусочков (`GE`, `T `, `/k`, `ar`, `ti`, `nk`, `a.j` и т.д.) и отправляется так. Некоторые ТСПУ не умеют правильно собирать такие пазлы.
  - `--dpi-desync-split-pos=N` (или marker+N): Указывает, где именно резать. Например, "резать после 2-го символа" или "резать посередине названия сайта".
- `multidisorder`: То же самое, что `multisplit`, но кусочки отправляются вперемешку, не по порядку. Это еще больше путает ТСПУ.
- `fakedsplit` / `fakeddisorder`: Более сложная "нарезка". Ваш запрос делится (например, на 2 части). Каждая часть "оборачивается" с двух сторон фальшивыми данными. То есть отправляется что-то вроде: `фальшивка` + `1-я часть запроса` + `фальшивка` ... и так же со второй частью. ТСПУ видит много мусора и может не найти настоящий запрос.
  - `--dpi-desync-fakedsplit-pattern=<файл_или_HEX>`: Чем заполнять эти фальшивые "обертки".
- `ipfrag1` / `ipfrag2`: Это тоже "нарезка", но на более низком уровне сети (на уровне IP-пакетов, а не TCP-сегментов). Иногда работает, если обычная "нарезка" не помогает.
- `hopbyhop` / `destopt` (только для IPv6): В пакеты добавляются специальные заголовки IPv6. Идея в том, что ТСПУ может посмотреть только на первый заголовок, увидеть там что-то нестандартное и пропустить пакет, не анализируя его содержимое дальше.
- `udplen` (для UDP-трафика, например, некоторые VPN, онлайн-игры): Увеличивает или уменьшает размер UDP-пакета, добавляя или убирая "мусорные" данные. Некоторые ТСПУ ожидают пакеты определенного размера для известных протоколов.
  - `--dpi-desync-udplen-increment=<число>`: На сколько байт изменить размер.
  - `--dpi-desync-udplen-pattern=<файл_или_HEX>`: Чем заполнять, если увеличиваем.
- `tamper`: "Подправить" пакеты известных протоколов (пока в основном для DHT из торрентов) так, чтобы ТСПУ их не узнал, а сам протокол продолжал работать.

### Другие важные опции, связанные с --dpi-desync
- `--dpi-desync-fwmark=<число>`: Специальная "метка" для пакетов, которые генерирует сама nfqws. Это нужно, чтобы программа случайно не начала обрабатывать свои же поддельные пакеты по второму кругу.
- `--dpi-desync-repeats=<N>`: Повторить отправку каждого сгенерированного поддельного пакета N раз.
- `--dpi-desync-skip-nosni=1`: Если это HTTPS-запрос, но в нем нет имени сайта (SNI) – не пытаться применять эти трюки. Обычно имя сайта есть, но если его нет, то и скрывать особо нечего.
- `--dpi-desync-any-protocol=1`: Применять трюки десинхронизации ко всем пакетам с данными, даже если nfqws не распознала протокол (например, какой-то редкий VPN). Использовать с осторожностью.
- `--dpi-desync-start=...N` / `--dpi-desync-cutoff=...N`: Начать/закончить применять трюки десинхронизации после N-го пакета или после передачи N байт данных. Полезно для протоколов, где важны только первые несколько пакетов.

## --dpi-desync-ttl
Представьте, что каждый пакет данных, который вы отправляете в интернет, – это как письмо с маркой, на которой написано число. Это число – **TTL (Time To Live, "Время Жизни")**.

Каждый раз, когда ваше "письмо" проходит через какой-то узел в интернете (например, роутер вашего провайдера, потом магистральный роутер, потом еще один, и так далее, пока не дойдет до сервера), этот узел "списывает" единичку с числа на марке. Если число на марке доходит до 0 до того, как письмо достигло адресата, то узел, на котором это произошло, выбрасывает письмо и отправляет вам обратно сообщение "Извините, ваше письмо не дошло, время жизни истекло".

Это сделано для того, чтобы "письма" не летали по интернету вечно, если вдруг произошла какая-то ошибка в маршруте.

Когда мы используем трюк с отправкой "поддельного" пакета (например, с помощью `--dpi-desync=fake`), мы хотим, чтобы:

1.  **"Интернет-Цензор" (DPI) этот поддельный пакет УВИДЕЛ.** DPI обычно находится где-то близко к вам, на сети вашего провайдера.
2.  **Настоящий сервер (сайт, к которому вы обращаетесь) этот поддельный пакет НЕ УВИДЕЛ.** Если поддельный пакет дойдет до сайта, это может вызвать ошибки или просто бессмысленно нагрузить сервер.

Вот тут-то и помогает **`--dpi-desync-ttl=<число>`**. Эта команда говорит: "Для всех *поддельных* пакетов, которые мы генерируем для обмана DPI, установи 'время жизни' равным этому <числу>."

Мы подбираем такое маленькое <число> (например, 3, 5 или 10), чтобы:

*   Этого "времени жизни" хватило, чтобы поддельный пакет долетел до вашего "Интернет-Цензора" (DPI), который обычно находится всего в нескольких "прыжках" (хопах) от вас.
*   Этого "времени жизни" НЕ хватило, чтобы поддельный пакет долетел до далекого сервера назначения. Пакет "умрет" где-то по пути, не достигнув сервера.

Допустим, ваш DPI находится в 2 "прыжках" от вас, а реальный сервер – в 15 "прыжках". Если вы поставите `--dpi-desync-ttl=3`, то:
*   Поддельный пакет пройдет 1-й прыжок, TTL станет 2.
*   Пройдет 2-й прыжок (DPI его увидит!), TTL станет 1.
*   Пройдет 3-й прыжок, TTL станет 0. На этом узле пакет будет отброшен. Он не дойдет до сервера.

Подбор правильного значения TTL самая сложная часть.

*   Если TTL будет **слишком маленьким**, поддельный пакет может не долететь даже до DPI, и обман не сработает.
*   Если TTL будет **слишком большим**, поддельный пакет долетит до сервера, что может вызвать проблемы.

Нужно найти "золотую середину". Часто это делается методом проб и ошибок. Обычно начинают с небольших значений (3-5) и постепенно увеличивают, пока обход блокировки не начнет работать, но при этом сайты не начнут "глючить".

**`--dpi-desync-autottl=[<дельта>[:<мин>[-<макс>]]|-]` – Автоматическая настройка TTL**

Это более умный вариант. Программа пытается сама определить, сколько "прыжков" до сервера, и на основе этого рассчитать TTL для поддельных пакетов.

*   `дельта`: Насколько TTL поддельного пакета должен отличаться от "расчетного пути" до сервера. Обычно это отрицательное число (например, `-2` или `1` без знака, что тоже значит минус), чтобы пакет "умер" чуть раньше, чем дойдет до сервера. Или положительное, если мы хотим, чтобы он все же дошел (редко для фейков).
*   `мин-макс`: Минимальное и максимальное значение TTL, которое может быть установлено, даже если расчеты показывают другое. Это страховка.

**Как работает `autottl`**

1.  Программа смотрит на TTL пакетов, приходящих *от* сервера к вам (для этого нужно, чтобы и входящий трафик немного обрабатывался `nfqws`).
2.  Зная стандартные начальные TTL (обычно 64, 128 или 255), она может примерно посчитать, сколько "прыжков" до сервера.
3.  Затем она берет это количество прыжков, прибавляет (или отнимает) `дельту` и получает TTL для поддельного пакета.

**Проблемы с `autottl`**

*   Некоторые серверы (например, Google) используют нестандартный начальный TTL, и расчеты могут быть неверными.
*   Если путь туда и обратно несимметричен (что бывает), расчеты тоже могут быть неточными.

**В каких случаях `--dpi-desync-ttl` или `--dpi-desync-autottl` полезны?**

Они используются вместе с теми режимами `--dpi-desync`, которые генерируют *дополнительные* пакеты (например, `fake`, `rst`, `rstack`), и вы хотите, чтобы эти пакеты увидел DPI, но не увидел конечный сервер.
Это один из самых распространенных и эффективных способов "обмана", если правильно подобрать значение TTL.

**Когда не нужно?**

Если ваш метод обмана не создает отдельных "фейковых" пакетов, которые нужно остановить на полпути (например, вы просто меняете регистр в HTTP-заголовке с помощью `--hostcase`), то `--dpi-desync-ttl` не нужен.

## --dpi-desync-fooling
Это как раз набор инструментов, чтобы "обмануть" сервер, заставив его проигнорировать наши поддельные пакеты, в то время как "Интернет-Цензор" (DPI) их увидит и, возможно, пропустит наш настоящий трафик. Это дополнение к основной стратегии из `--dpi-desync`.

Когда мы используем `--dpi-desync` с режимами, которые создают *дополнительные, поддельные пакеты* (например, `--dpi-desync=fake`), у нас есть проблема:

1.  Мы хотим, чтобы DPI **увидел** эти поддельные пакеты и подумал, что мы делаем что-то безобидное.
2.  Мы НЕ хотим, чтобы настоящий сервер (сайт, к которому мы обращаемся) **обработал** эти поддельные пакеты. Если сервер их обработает, это может:
    *   Сломать наше настоящее соединение.
    *   Вызвать ошибки на сайте.
    *   Просто создать ненужную нагрузку.

`--dpi-desync-fooling` предлагает разные способы, как сделать так, чтобы сервер "отфутболил" наши поддельные пакеты, а DPI – нет.

Вы можете указать один или несколько трюков через запятую (например, `--dpi-desync-fooling=md5sig, badsum`).

- `none`: Не использовать никаких специальных трюков для обмана сервера. Поддельный пакет отправляется "как есть". Обычно это используется, если вы полагаетесь только на TTL (`--dpi-desync-ttl`), чтобы пакет не дошел до сервера.
- `md5sig`: Добавить в TCP-пакет специальную опцию "MD5 signature" (цифровая подпись).
    *   **Как работает:** Многие серверы (особенно те, что работают на Linux) не любят эту опцию, если она не была согласована заранее, и просто отбрасывают такие пакеты.
    *   **DPI:** DPI может быть настроен так, чтобы не обращать внимания на эту опцию или не уметь ее правильно проверять, поэтому он может "проглотить" такой пакет.
    *   **Минус:** Требует дополнительного места в пакете. Если пакет и так большой, это может вызвать проблемы. Не все серверы отбрасывают такие пакеты (например, Windows-серверы могут их принять).
-  `badsum`: Испортить контрольную сумму TCP-пакета.
    *   **Как работает:** Контрольная сумма – это как проверка на то, что пакет не повредился при передаче. Если сумма неправильная, сервер почти наверняка отбросит пакет как "битый".
    *   **DPI:** DPI может не проверять контрольную сумму или проверять ее до того, как она "испортится" (если порча происходит на вашем устройстве).
    *   **Минусы:**
        *   **Очень большой минус:** Если ваш компьютер находится за домашним роутером (NAT), этот роутер сам может проверять контрольные суммы и не пропустить такой "испорченный" пакет дальше в интернет. То есть, пакет даже до DPI не дойдет. На некоторых роутерах (например, OpenWrt) эту проверку можно отключить.
        *   Некоторые сетевые карты/драйверы могут сами "исправлять" плохую контрольную сумму или отбрасывать такие пакеты еще до того, как они попадут в программу.
- `badseq`: Испортить порядковый номер TCP-пакета (sequence number).
    *   **Как работает:** TCP-пакеты передаются с порядковыми номерами, чтобы сервер мог собрать их в правильном порядке. Если приходит пакет с номером, который сильно "выбивается" из ожидаемой последовательности (например, слишком большой или слишком маленький), сервер его, скорее всего, отбросит.
    *   **DPI:** DPI может не так строго следить за порядковыми номерами или ожидать пакеты в более широком диапазоне.
    *   **Нюанс:** Значение, на которое изменяется номер, можно настроить (`--dpi-desync-badseq-increment`). Иногда слишком маленькое смещение может не сработать, а слишком большое – вызвать проблемы, если вы отправляете много данных.
- `ttl`: (Хотя `ttl` чаще настраивается отдельным параметром `--dpi-desync-ttl`, его упоминание здесь означает, что это тоже способ "fooling", чтобы пакет не дошел до сервера). Мы уже подробно разбирали TTL. Идея в том, чтобы пакет "умер" по пути к серверу, но после того, как его увидел DPI.
- `hopbyhop` / `hopbyhop2` (только для IPv6): Добавить в пакет IPv6 специальный заголовок "hop-by-hop options".
    *   **Как работает:**
        *   `hopbyhop`: Один такой заголовок обычно принимается серверами, но некоторые провайдеры или промежуточные узлы могут фильтровать пакеты с ним. Расчет на то, что DPI его проанализирует, а до сервера он не дойдет из-за фильтрации.
        *   `hopbyhop2`: Добавляются *два* таких заголовка. Это нарушение стандарта, и почти все операционные системы гарантированно отбросят такой пакет.
    *   **DPI:** DPI может проанализировать пакет с одним или даже двумя такими заголовками, не поняв, что он "неправильный" для сервера.
- `datanoack`: Отправить поддельный пакет с данными, но снять с него TCP-флаг ACK (подтверждение).
    *   **Как работает:** Серверы обычно не принимают пакеты с данными без флага ACK (кроме самого первого SYN-пакета).
    *   **DPI:** DPI может принять такой пакет к анализу.
    *   **Минусы:**
        *   Может плохо работать с NAT (особенно если ваш компьютер за домашним роутером с Linux, который использует `masquerade`).
        *   Некоторые провайдерские NAT тоже могут его отбрасывать.

Цель `--dpi-desync-fooling` – увеличить шансы, что ваш поддельный пакет будет проигнорирован сервером, но при этом принят и проанализирован DPI.

Выбор конкретного метода или их комбинации зависит от:

*   **Как настроен DPI вашего провайдера:** Что он проверяет, а что нет?
*   **Как настроен сервер, к которому вы обращаетесь:** Какие "неправильные" пакеты он отбрасывает?
*   **Ваша собственная сетевая конфигурация:** Есть ли у вас NAT, какой у вас роутер?

Часто это **путь экспериментов**. Начинают с чего-то одного (например, `ttl` через `--dpi-desync-ttl` + `md5sig` через `--dpi-desync-fooling`), смотрят, работает ли. Если нет – пробуют другие комбинации.

## --dpi-desync-repeats
Использовать его стоит обдуманно и в сочетании с другими параметрами. Вы пытаетесь пробить ТСПУ и для этого Вы создаете отвлекающий маневр (например, посылаете поддельный пакет с помощью `--dpi-desync=fake`). Параметр `--dpi-desync-repeats=<N>` говорит вашей программе: "Когда ты создаешь какой-либо отвлекающий маневр (любой пакет, сгенерированный в рамках `--dpi-desync`, например, `fake`, `rst` или части `multisplit`), **повтори его отправку N раз подряд** перед тем, как делать что-то дальше."

Допустим, вы настроили: `--dpi-desync=fake --dpi-desync-repeats=3`

И программа решила послать поддельный пакет (назовем его `Фейк_Пакет`).

Без `--dpi-desync-repeats` она бы отправила: `Фейк_Пакет` -> `Ваш_Настоящий_Запрос`

С `--dpi-desync-repeats=3` она отправит: `Фейк_Пакет` -> `Фейк_Пакет` -> `Фейк_Пакет` -> `Ваш_Настоящий_Запрос`

**Если у вас несколько этапов десинхронизации:**

Допустим, у вас сложная стратегия, например: `--dpi-desync=fake,multisplit --dpi-desync-repeats=2`

И `multisplit` делит ваш настоящий запрос на два куска: `Кусок1` и `Кусок2`.

А `fake` генерирует `Фейк_Пакет`.

Тогда последовательность будет примерно такой (упрощенно):

1.  Сначала идет `fake` (Фаза 1):
    *   `Фейк_Пакет`
    *   `Фейк_Пакет` (повтор)
2.  Потом идет `multisplit` (Фаза 2), который обрабатывает ваш настоящий запрос:
    *   `Кусок1` (это уже часть вашего настоящего, модифицированного запроса, а не сгенерированный "фейк" для отвлечения, поэтому `repeats` на него здесь не действует так прямо, как на `fake`. `repeats` влияет на *каждый генерируемый в nfqws пакет* в рамках стратегий desync.)
    *   `Кусок2`

**Корректнее будет так:** Если `nfqws` *генерирует* пакет в рамках стратегии `dpi-desync` (а это все пакеты в режиме `fake`, `rst`, `rstack`, и все *новые* сегменты, создаваемые при `multisplit`, `fakedsplit` и т.д. из оригинального пакета), то *каждый* такой сгенерированный пакет будет повторен `N` раз.

Если `multisplit` разрезал один оригинальный пакет на `Сегмент_А` и `Сегмент_Б`, то с `--dpi-desync-repeats=2` будет: `Сегмент_А` -> `Сегмент_А` -> `Сегмент_Б` -> `Сегмент_Б`

Если перед этим еще был `fake`: `Фейк_Пакет` -> `Фейк_Пакет` -> `Сегмент_А` -> `Сегмент_А` -> `Сегмент_Б` -> `Сегмент_Б`

**Зачем это может быть нужно?**

1.  **Усиление "шума":** Некоторые DPI могут проигнорировать один подозрительный пакет, но если таких пакетов придет несколько подряд, это может с большей вероятностью "занять" их внимание или вызвать ошибку в их логике.
2.  **Борьба с потерей пакетов:** Если сеть нестабильна и некоторые поддельные пакеты могут потеряться, отправка нескольких копий увеличивает шанс, что хотя бы одна дойдет до DPI.
3.  **Специфические уязвимости DPI:** Возможно, какой-то конкретный DPI "спотыкается" или входит в неправильное состояние, если получает несколько одинаковых пакетов подряд.

**Когда это использовать?**

*   Когда простые методы десинхронизации не работают.
*   Когда есть подозрение, что DPI "фильтрует" единичные аномалии, но может пропустить серию.
*   В качестве эксперимента, если другие опции не помогли.

**Важно:**

*   **Не влияет на обычные пакеты:** Эта опция повторяет только те пакеты, которые *генерируются или модифицируются самой `nfqws`* в рамках стратегий `--dpi-desync`. Она не повторяет все подряд ваши пакеты.
*   **Увеличивает трафик:** Очевидно, что отправка копий увеличивает объем передаваемых данных, хоть и ненамного, так как фейковые пакеты обычно маленькие.
*   **Может быть излишним:** Если простой `fake` работает, то повторять его, возможно, и не нужно.


## --dpi-desync-fake
Техника `fake` заключается в том, чтобы перед тем, как отправить ваш настоящий, возможно, "подозрительный" запрос, вы **сначала бросаете "кусок колбасы" – совершенно другой, безобидный, поддельный запрос.**

DPI видит этот поддельный запрос, думает: "Ага, это что-то разрешенное, все в порядке", и, возможно, ослабляет бдительность или неправильно классифицирует ваше последующее соединение. После этого вы отправляете свой настоящий запрос, и есть шанс, что он "проскочит" незамеченным.

**Как это используется в `nfqws`:**

Вы включаете режим `fake` в основной команде:
`--dpi-desync=fake` (или в комбинации, например, `--dpi-desync=fake,multisplit`)

А затем вы можете уточнить, *какую именно* "приманку" (поддельный запрос) использовать, с помощью параметров `--dpi-desync-fake-...`:

1.  **`--dpi-desync-fake-http=<filename>|0xHEX`**:
    *   **Назначение:** Указать, какой поддельный **HTTP**-запрос (для обычных, незашифрованных сайтов) отправлять.
    *   **Как использовать:**
        *   `<filename>`: Вы можете создать текстовый файл, в котором будет написан полный, корректный HTTP-запрос к какому-нибудь известному разрешенному сайту (например, `GET / HTTP/1.1\r\nHost: www.iana.org\r\n\r\n`). `nfqws` прочитает этот файл и будет использовать его содержимое как "приманку".
        *   `0xHEX`: Можно указать содержимое запроса прямо в командной строке в виде шестнадцатеричного кода (HEX). Это менее удобно для длинных запросов.
    *   **По умолчанию:** Если вы не укажете этот параметр, `nfqws` обычно использует встроенный стандартный фейковый HTTP-запрос (часто к `www.iana.org`).
2.  **`--dpi-desync-fake-tls=<filename>|0xHEX|!`**:
    *   **Назначение:** Указать, какой поддельный **TLS ClientHello**-пакет (это начальный пакет для **HTTPS**-соединений, зашифрованных сайтов) отправлять.
    *   **Как использовать:**
        *   `<filename>`: Аналогично HTTP, вы можете записать в файл содержимое реального TLS ClientHello-пакета (например, перехваченного при обращении к разрешенному сайту).
        *   `0xHEX`: Тоже можно, но для TLS ClientHello это будет очень длинная строка.
        *   `!`: Специальный символ, означающий "использовать стандартный встроенный фейковый TLS ClientHello". Это удобно, если вы не хотите заморачиваться с созданием своего файла, но хотите явно указать, что нужен стандартный фейк.
    *   **По умолчанию:** Если не указано, используется стандартный встроенный фейк.
    *   **Модификация фейков TLS:** Есть еще параметр `--dpi-desync-fake-tls-mod=...`, который позволяет на лету изменять некоторые части этого фейкового TLS-пакета (например, рандомизировать Session ID или подставить другое имя сайта в SNI). Это делает "приманку" более разнообразной.
3.  **`--dpi-desync-fake-quic=<filename>|0xHEX`**:
    *   **Назначение:** Для протокола QUIC (часто используется Google, это альтернатива TCP/TLS для ускорения соединений). Позволяет задать поддельный начальный QUIC-пакет.
4.  **`--dpi-desync-fake-wireguard=<filename>|0xHEX`**:
    *   **Назначение:** Для VPN-протокола WireGuard. Позволяет задать поддельный пакет инициации рукопожатия.
5.  **И другие `fake-` параметры для конкретных протоколов:**
    *   `--dpi-desync-fake-dht=...` (для торрентов)
    *   `--dpi-desync-fake-discord=...` (для голосовых чатов Discord)
    *   `--dpi-desync-fake-stun=...` (для определения внешнего IP, используется во многих VoIP и P2P приложениях)
    *   `--dpi-desync-fake-unknown-udp=...` (для неопознанного UDP-трафика, если включено `--dpi-desync-any-protocol=1`)
    *   `--dpi-desync-fake-unknown=...` (для неопознанного TCP-трафика, если включено `--dpi-desync-any-protocol=1`)
    *   `--dpi-desync-fake-syndata=...` (специальные данные для добавления в SYN-пакет в режиме `syndata`)

**Зачем нужны свои фейковые пакеты?**

*   **Уникальность:** Стандартные фейки могут быть известны продвинутым DPI. Использование своего, уникального фейкового запроса (например, к локальному сайту вашего провайдера, который точно разрешен) может быть эффективнее.
*   **Точная имитация:** Вы можете идеально сымитировать трафик к разрешенному ресурсу, что сделает "приманку" более правдоподобной.
*   **Эксперименты:** Можно пробовать разные фейки, чтобы найти тот, на который ваш DPI "клюет" лучше всего.

**Важные моменты при использовании `fake`:**

*   **"Fooling":** Как мы обсуждали ранее (`--dpi-desync-fooling`), очень важно, чтобы этот поддельный пакет не дошел до реального сервера назначения (которому он не предназначался) или был им проигнорирован. Иначе могут быть ошибки. TTL (`--dpi-desync-ttl`) или другие методы "fooling" здесь критичны.
*   **Размер фейка:** Слишком большой фейковый пакет может вызвать проблемы с MTU (максимальный размер пакета).
*   **Корректность фейка:** Если вы создаете свой фейковый пакет, он должен быть синтаксически корректным для соответствующего протокола, иначе он может быть отброшен даже DPI.

## --dpi-desync-fake-tls-mod
Когда вы используете `--dpi-desync=fake` для HTTPS-сайтов, `nfqws` отправляет поддельный пакет "TLS ClientHello". Этот пакет — самое первое, что ваш браузер отправляет серверу, чтобы начать зашифрованное HTTPS-соединение. В нем содержится информация о том, какие шифры вы поддерживаете, имя сайта, к которому вы хотите подключиться (в поле SNI — Server Name Indication), и другие технические детали.

Вы можете предоставить свой собентвенный файл с таким поддельным ClientHello (`--dpi-desync-fake-tls=<filename>`).

Параметр `--dpi-desync-fake-tls-mod` позволяет немного **изменять этот поддельный ClientHello "на лету"** при каждом его использовании. Это делает вашу "приманку" менее статичной и, возможно, более эффективной против DPI, которые могут запоминать и блокировать одинаковые поддельные пакеты.

**Режимы модификации (`mod`):**

Вы можете указать один или несколько режимов через запятую.

1.  `none`:
    *   **Что делает:** Ничего не изменять. Использовать поддельный TLS ClientHello точно таким, какой он есть (из файла или встроенный по умолчанию).
    *   **Когда использовать:** Если вы уверены, что ваш статический фейк работает, или если другие модификации что-то ломают.

2.  `rnd`:
    *   **Что делает:** "Рандомизировать" (делать случайными) два поля в поддельном TLS ClientHello:
        *   `random`: Это 32 байта случайных данных, которые используются в процессе шифрования.
        *   `session id`: Идентификатор сессии, который может использоваться для быстрого возобновления предыдущего соединения.
    *   **Зачем:** Делает каждый отправляемый поддельный ClientHello немного уникальным, даже если сам файл-фейк один и тот же. Это может затруднить DPI задачу по созданию точной "сигнатуры" вашего фейка.
    *   **Когда использовать:** Почти всегда хорошая идея, если вы используете `fake` для TLS.

3.  `rndsni`:
    *   **Что делает:** Рандомизировать поле SNI (Server Name Indication) в поддельном TLS ClientHello. SNI — это то место, где указывается, к какому именно сайту вы хотите подключиться (например, `www.google.com`).
        *   Если оригинальное SNI в вашем фейке достаточно длинное (7+ символов), программа подставит случайное доменное имя второго уровня с известным TLD (например, `randomword.com`, `another.org`).
        *   Если короткое, то заполнит случайными символами без точки.
    *   **Зачем:** DPI часто смотрят на SNI, чтобы определить, к какому сайту вы обращаетесь. Отправляя фейк с постоянно меняющимся (но валидным на вид) SNI к разрешенному домену, вы можете запутать DPI.
    *   **Когда использовать:** Хорошо сочетается с `rnd`. Выполняется один раз при старте программы (т.е. SNI в фейке будет заменено на одно случайное значение на все время работы `nfqws`, если только не перезапустить).

4.  `sni=<sni_value>`:
    *   **Что делает:** Принудительно заменить SNI в вашем поддельном TLS ClientHello на указанное вами `<sni_value>`. Например, `sni=www.wikipedia.org`.
    *   **Зачем:** Позволяет точно указать, под какой разрешенный сайт вы хотите "маскировать" свой фейковый запрос.
    *   **Когда использовать:** Если вы точно знаете, что фейковый запрос к определенному разрешенному сайту хорошо работает.
    *   **Важно:** Длина `<sni_value>` ограничена (обычно 63 байта). Программа автоматически подправит все длины внутри TLS-пакета, чтобы он остался корректным. Выполняется один раз при старте. Если используется вместе с `rndsni`, то `sni=` выполняется первым.

5.  `dupsid`:
    *   **Что делает:** Копировать поле `session ID` из *вашего настоящего* TLS ClientHello (который вы отправляете на заблокированный сайт) в *поддельный* TLS ClientHello.
    *   **Зачем:** Некоторые DPI могут обращать внимание на согласованность `session ID` между фейковым и реальным запросами. Если они совпадают, это может сделать вашу попытку обхода менее подозрительной для такого DPI.
    *   **Когда использовать:** Может быть полезно, если DPI анализирует состояние TCP-сессии и следит за `session ID`. Имеет приоритет над `rnd` в части `session ID`.

6.  `padencap` (Padding Encapsulation):
    *   **Что делает:** Это более сложный трюк. Идея в том, чтобы заставить DPI думать, будто ваш *настоящий* TLS ClientHello (даже если он большой и состоит из нескольких пакетов, как с шифрованием Kyber) является всего лишь "набивкой" (padding) внутри *поддельного* TLS ClientHello.
        *   Программа берет ваш поддельный TLS ClientHello.
        *   Находит в нем (или добавляет, если нет) специальное TLS-расширение "padding" (это просто мусорные данные для выравнивания длины).
        *   Изменяет длины в этом padding-расширении так, чтобы казалось, будто оно содержит в себе весь ваш настоящий ClientHello.
        *   Размер самого поддельного пакета при этом не меняется!
    *   **Зачем:** Расчет на DPI, который не очень внимательно проверяет порядковые номера TCP-сегментов (sequence numbers) и может "купиться" на то, что весь ваш реальный запрос — это просто часть "мусорной" набивки в легитимном на вид поддельном запросе.
    *   **Когда использовать:** Продвинутый метод. Может сработать против DPI, которые пытаются собирать многопакетные TLS ClientHello, но делают это не очень аккуратно. Требует, чтобы ваш фейковый TLS ClientHello был полным и валидным, и чтобы padding-расширение (если оно есть) было последним.

**Как это все работает вместе:**

*   По умолчанию, если вы **не** указываете свой файл для `--dpi-desync-fake-tls`, то `nfqws` использует стандартный встроенный фейк и автоматически применяет к нему модификации `rnd,rndsni,dupsid`.
*   Если вы **указываете свой файл** для `--dpi-desync-fake-tls` (например, `moysuperfake.bin`), то по умолчанию используется `dpi-desync-fake-tls-mod=none`. Если вы хотите применить модификации к своему файлу, вы должны явно их указать, например: `--dpi-desync-fake-tls=moysuperfake.bin --dpi-desync-fake-tls-mod=rnd,dupsid`.

**Пример использования:**

`--dpi-desync=fake --dpi-desync-fake-tls=my_fake_client_hello.bin --dpi-desync-fake-tls-mod=rnd,sni=www.allowed-site.com,dupsid`

Это скажет `nfqws`:
1.  Использовать режим `fake`.
2.  В качестве поддельного TLS ClientHello взять данные из файла `my_fake_client_hello.bin`.
3.  Перед отправкой этого фейка:
    *   Рандомизировать его поля `random`.
    *   Заменить SNI в нем на `www.allowed-site.com`.
    *   Скопировать `session ID` из настоящего ClientHello в этот фейк.
